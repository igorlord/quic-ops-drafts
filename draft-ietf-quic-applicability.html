<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Applicability of the QUIC Transport Protocol</title>

  
<style type="text/css">/*<![CDATA[*/

body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 624px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Roboto Condensed","Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 1.2em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract p {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre, span.tt {
  font: 13.5px Consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

p, ol, ul, li {
  padding: 0;
}
p {
  margin: 0.5em 0;
}
ol, ul {
  margin: 0.2em 0 0.2em 2em;
}
li {
  margin: 0.2em 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 924px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
/*]]>*/</style>
<meta name="viewport" content="initial-scale=1.0">


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Notational Conventions">
<link href="#rfc.section.2" rel="Chapter" title="2 The Necessity of Fallback">
<link href="#rfc.section.3" rel="Chapter" title="3 Zero RTT">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Thinking in Zero RTT">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Here There Be Dragons">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Session resumption versus Keep-alive">
<link href="#rfc.section.4" rel="Chapter" title="4 Use of Streams">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Stream versus Flow Multiplexing">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Prioritization">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Flow Control Deadlocks">
<link href="#rfc.section.5" rel="Chapter" title="5 Packetization and Latency">
<link href="#rfc.section.6" rel="Chapter" title="6 Port Selection">
<link href="#rfc.section.7" rel="Chapter" title="7 Connection Migration">
<link href="#rfc.section.8" rel="Chapter" title="8 Connection closure">
<link href="#rfc.section.9" rel="Chapter" title="9 Information exposure and the Connection ID">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Server-Generated Connection ID">
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Mitigating Timing Linkability with Connection ID Migration">
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 Using Server Retry for Redirection">
<link href="#rfc.section.10" rel="Chapter" title="10 Use of Versions and Cryptographic Handshake">
<link href="#rfc.section.11" rel="Chapter" title="11 Enabling New Versions">
<link href="#rfc.section.12" rel="Chapter" title="12 IANA Considerations">
<link href="#rfc.section.13" rel="Chapter" title="13 Security Considerations">
<link href="#rfc.section.14" rel="Chapter" title="14 Contributors">
<link href="#rfc.section.15" rel="Chapter" title="15 Acknowledgments">
<link href="#rfc.references" rel="Chapter" title="16 References">
<link href="#rfc.references.1" rel="Chapter" title="16.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="16.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.22.1 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Kuehlewind, M. and B. Trammell" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-quic-applicability-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-07-04" />
  <meta name="dct.abstract" content="This document discusses the applicability of the QUIC transport protocol, focusing on caveats impacting application protocol development and deployment over QUIC. Its intended audience is designers of application protocol mappings to QUIC, and implementors of these application protocols." />
  <meta name="description" content="This document discusses the applicability of the QUIC transport protocol, focusing on caveats impacting application protocol development and deployment over QUIC. Its intended audience is designers of application protocol mappings to QUIC, and implementors of these application protocols." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">M. Kuehlewind</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Ericsson</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">B. Trammell</td>
</tr>
<tr>
<td class="left">Expires: January 5, 2020</td>
<td class="right">Google</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">July 04, 2019</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Applicability of the QUIC Transport Protocol<br />
  <span class="filename">draft-ietf-quic-applicability-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document discusses the applicability of the QUIC transport protocol, focusing on caveats impacting application protocol development and deployment over QUIC. Its intended audience is designers of application protocol mappings to QUIC, and implementors of these application protocols.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on January 5, 2020.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Notational Conventions</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">The Necessity of Fallback</a>
</li>
<li>3.   <a href="#rfc.section.3">Zero RTT</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Thinking in Zero RTT</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Here There Be Dragons</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Session resumption versus Keep-alive</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Use of Streams</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Stream versus Flow Multiplexing</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Prioritization</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Flow Control Deadlocks</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Packetization and Latency</a>
</li>
<li>6.   <a href="#rfc.section.6">Port Selection</a>
</li>
<li>7.   <a href="#rfc.section.7">Connection Migration</a>
</li>
<li>8.   <a href="#rfc.section.8">Connection closure</a>
</li>
<li>9.   <a href="#rfc.section.9">Information exposure and the Connection ID</a>
</li>
<ul><li>9.1.   <a href="#rfc.section.9.1">Server-Generated Connection ID</a>
</li>
<li>9.2.   <a href="#rfc.section.9.2">Mitigating Timing Linkability with Connection ID Migration</a>
</li>
<li>9.3.   <a href="#rfc.section.9.3">Using Server Retry for Redirection</a>
</li>
</ul><li>10.   <a href="#rfc.section.10">Use of Versions and Cryptographic Handshake</a>
</li>
<li>11.   <a href="#rfc.section.11">Enabling New Versions</a>
</li>
<li>12.   <a href="#rfc.section.12">IANA Considerations</a>
</li>
<li>13.   <a href="#rfc.section.13">Security Considerations</a>
</li>
<li>14.   <a href="#rfc.section.14">Contributors</a>
</li>
<li>15.   <a href="#rfc.section.15">Acknowledgments</a>
</li>
<li>16.   <a href="#rfc.references">References</a>
</li>
<ul><li>16.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>16.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">QUIC <a href="#QUIC" class="xref">[QUIC]</a> is a new transport protocol currently under development in the IETF quic working group, focusing on support of semantics as needed for HTTP/2 <a href="#QUIC-HTTP" class="xref">[QUIC-HTTP]</a> such as stream-multiplexing to avoid head-of-line blocking. Based on current deployment practices, QUIC is encapsulated in UDP. The version of QUIC that is currently under development will integrate TLS 1.3 <a href="#TLS13" class="xref">[TLS13]</a> to encrypt all payload data and most control information.</p>
<p id="rfc.section.1.p.2">This document provides guidance for application developers that want to use the QUIC protocol without implementing it on their own. This includes general guidance for application use of HTTP/2 over QUIC as well as the use of other application layer protocols over QUIC. For specific guidance on how to integrate HTTP/2 with QUIC, see <a href="#QUIC-HTTP" class="xref">[QUIC-HTTP]</a>.</p>
<p id="rfc.section.1.p.3">In the following sections we discuss specific caveats to QUIC&#8217;s applicability, and issues that application developers must consider when using QUIC as a transport for their application.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#notational-conventions" id="notational-conventions">Notational Conventions</a>
</h1>
<p id="rfc.section.1.1.p.1">The words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;SHOULD&#8221;, and &#8220;MAY&#8221; are used in this document.  It&#8217;s not shouting; when these words are capitalized, they have a special meaning as defined in <a href="#RFC2119" class="xref">[RFC2119]</a>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#fallback" id="fallback">The Necessity of Fallback</a>
</h1>
<p id="rfc.section.2.p.1">QUIC uses UDP as a substrate for userspace implementation and port numbers for NAT and middlebox traversal. While there is no evidence of widespread, systematic disadvantage of UDP traffic compared to TCP in the Internet <a href="#Edeline16" class="xref">[Edeline16]</a>, somewhere between three <a href="#Trammell16" class="xref">[Trammell16]</a> and five <a href="#Swett16" class="xref">[Swett16]</a> percent of networks simply block UDP traffic. All applications running on top of QUIC must therefore either be prepared to accept connectivity failure on such networks, or be engineered to fall back to some other transport protocol.  This fallback SHOULD provide TLS 1.3 or equivalent cryptographic protection, if available, in order to keep fallback from being exploited as a downgrade attack. In the case of HTTP, this fallback is TLS 1.3 over TCP.</p>
<p id="rfc.section.2.p.2">These applications must operate, perhaps with impaired functionality, in the absence of features provided by QUIC not present in the fallback protocol. For fallback to TLS over TCP, the most obvious difference is that TCP does not provide stream multiplexing and therefore stream multiplexing would need to be implemented in the application layer if needed. Further, TCP without the TCP Fast Open extension does not support 0-RTT session resumption. TCP Fast Open can be requested by the connection initiator but might no be supported by the far end or could be blocked on the network path. Note that there is some evidence of middleboxes blocking SYN data even if TFO was successfully negotiated (see <a href="#PaaschNanog" class="xref">[PaaschNanog]</a>).</p>
<p id="rfc.section.2.p.3">Any fallback mechanism is likely to impose a degradation of performance; however, fallback MUST not silently violate the application&#8217;s expectation of confidentiality or integrity of its payload data.</p>
<p id="rfc.section.2.p.4">Moreover, while encryption (in this case TLS) is inseparably integrated with QUIC, TLS negotiation over TCP can be blocked. In case it is RECOMMENDED to abort the connection, allowing the application to present a suitable prompt to the user that secure communication is unavailable.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#zero-rtt" id="zero-rtt">Zero RTT</a>
</h1>
<p id="rfc.section.3.p.1">QUIC provides for 0-RTT connection establishment. This presents opportunities and challenges for applications using QUIC.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#thinking-in-zero-rtt" id="thinking-in-zero-rtt">Thinking in Zero RTT</a>
</h1>
<p id="rfc.section.3.1.p.1">A transport protocol that provides 0-RTT connection establishment to recently contacted servers is qualitatively different than one that does not from the point of view of the application using it. Relative trade-offs between the cost of closing and reopening a connection and trying to keep it open are different; see <a href="#resumption-v-keepalive" class="xref">Section 3.3</a>.</p>
<p id="rfc.section.3.1.p.2">Applications must be slightly rethought in order to make best use of 0-RTT resumption. Most importantly, application operations must be divided into idempotent and non-idempotent operations, as only idempotent operations may appear in 0-RTT packets. This implies that the interface between the application and transport layer exposes idempotence either explicitly or implicitly.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#here-there-be-dragons" id="here-there-be-dragons">Here There Be Dragons</a>
</h1>
<p id="rfc.section.3.2.p.1">Retransmission or (malicious) replay of data contained in 0-RTT resumption packets could cause the server side to receive two copies of the same data.  This is further described in <a href="#HTTP-RETRY" class="xref">[HTTP-RETRY]</a>.  Data sent during 0-RTT resumption also cannot benefit from perfect forward secrecy (PFS).</p>
<p id="rfc.section.3.2.p.2">Data in the first flight sent by the client in a connection established with 0-RTT MUST be idempotent (as specified in section 2.1 in <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>).  Applications MUST be designed, and their data MUST be framed, such that multiple reception of idempotent data is recognized as such by the receiverApplications that cannot treat data that may appear in a 0-RTT connection establishment as idempotent MUST NOT use 0-RTT establishment. For this reason the QUIC transport SHOULD provide an interface for the application to indicate if 0-RTT support is in general desired or a way to indicate whether data is idempotent, whether PFS is a hard requirement for the application, and/or whether rejected 0-RTT dgitata should be retransmitted or withdrawn.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#resumption-v-keepalive" id="resumption-v-keepalive">Session resumption versus Keep-alive</a>
</h1>
<p id="rfc.section.3.3.p.1">Because QUIC is encapsulated in UDP, applications using QUIC must deal with short idle timeouts. Deployed stateful middleboxes will generally establish state for UDP flows on the first packet state, and keep state for much shorter idle periods than for TCP. According to a 2010 study (<a href="#Hatonen10" class="xref">[Hatonen10]</a>), UDP applications can assume that any NAT binding or other state entry will be expired after just thirty seconds of inactivity.</p>
<p id="rfc.section.3.3.p.2">A QUIC application has three strategies to deal with this issue:</p>
<p></p>

<ul>
<li>Ignore it, if the application-layer protocol consists only of interactions with no or very short idle periods.</li>
<li>Ensure there are no long idle periods.</li>
<li>Resume the session after a long idle period, using 0-RTT resumption when appropriate.</li>
</ul>
<p id="rfc.section.3.3.p.4">The first strategy is the easiest, but it only applies to certain applications.</p>
<p id="rfc.section.3.3.p.5">Either the server or the client in a QUIC application can send PING frames as keep-alives, to prevent the connection and any on-path state from timing out.  Recommendations for the use of keep-alives are application specific, mainly depending on the latency requirements and message frequency of the application.  In this case, the application mapping must specify whether the client or server is responsible for keeping the application alive. Note that sending PING frames more frequently than every 30 seconds over long idle periods may result in a too much unproductive traffic and power usage for some situations.</p>
<p id="rfc.section.3.3.p.6">Alternatively, the client (but not the server) can use session resumption instead of sending keepalive traffic. In this case, a client that wants to send data to a server over a connection idle longer than the server&#8217;s idle timeout (available from the idle_timeout transport parameter) can simply reconnect. When possible, this reconnection can use 0-RTT session resumption, reducing the latency involved with restarting the connection. This of course only applies in cases in which 0-RTT data is safe, when the client is the restarting peer, and when the data to be sent is idempotent.</p>
<p id="rfc.section.3.3.p.7">The tradeoffs between resumption and keepalive need to be evaluated on a per-application basis. However, in general applications should use keepalives only in circumstances where continued communication is highly likely; <a href="#QUIC-HTTP" class="xref">[QUIC-HTTP]</a>, for instance, recommends using PING frames for keepalive only when a request is outstanding.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#use-of-streams" id="use-of-streams">Use of Streams</a>
</h1>
<p id="rfc.section.4.p.1">QUIC&#8217;s stream multiplexing feature allows applications to run multiple streams over a single connection, without head-of-line blocking between streams, associated at a point in time with a single five-tuple. Stream data is carried within Frames, where one (UDP) packet on the wire can carry one of multiple stream frames.</p>
<p id="rfc.section.4.p.2">Stream can be independently open and closed, gracefully or by error. If a critical stream for the application is closed, the application can generate respective error messages on the application layer to inform the other end or the higher layer and eventually indicate QUIC to reset the connection. QUIC, however, does not need to know which streams are critical, and does not provide an interface to exceptional handling of any stream. There are special streams in QUIC that are used for control on the QUIC connection, however, these streams are not exposed to the application.</p>
<p id="rfc.section.4.p.3">Mapping of application data to streams is application-specific and described for HTTP/s in <a href="#QUIC-HTTP" class="xref">[QUIC-HTTP]</a>. In general data that can be processed independently, and therefore would suffer from head of line blocking, if forced to be received in order, should be transmitted over different streams.  If there is a logical grouping of those data chunks or messages, stream can be reused, or a new stream can be opened for each chunk/message. If one message is mapped on a single stream, resetting the stream if the message is not needed anymore can be used to emulate partialreliability on a message basis. If a QUIC receiver has maximum allowed concurrent streams open and the sender on the other end indicates that more streams are needed, it doesn&#8217;t automatically lead to an increase of the maximum number of streams by the receiver.  Therefore it can be valuable to expose maximum number of allowed, currently open and currently used streams to the application to make the mapping of data to streams dependent on this information.</p>
<p id="rfc.section.4.p.4">Further, streams have a maximum number of bytes that can be sent on one stream. This number is high enough (2^64) that this will usually not be reached with current applications. Applications that send chunks of data over a very long period of time (such as days, months, or years), should rather utilize the 0-RTT session resumption ability provided by QUIC, than trying to maintain one connection open.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#stream-versus-flow-multiplexing" id="stream-versus-flow-multiplexing">Stream versus Flow Multiplexing</a>
</h1>
<p id="rfc.section.4.1.p.1">Streams are meaningful only to the application; since stream information is carried inside QUIC&#8217;s encryption boundary, no information about the stream(s) whose frames are carried by a given packet is visible to the network.  Therefore stream multiplexing is not intended to be used for differentiating streams in terms of network treatment. Application traffic requiring different network treatment SHOULD therefore be carried over different five-tuples (i.e.  multiple QUIC connections). Given QUIC&#8217;s ability to send application data in the first RTT of a connection (if a previous connection to the same host has been successfully established to provide the respective credentials), the cost of establishing another connection is extremely low.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#prioritization" id="prioritization">Prioritization</a>
</h1>
<p id="rfc.section.4.2.p.1">Stream prioritization is not exposed to either the network or the receiver.  Prioritization is managed by the sender, and the QUIC transport should provide an interface for applications to prioritize streams <a href="#QUIC" class="xref">[QUIC]</a>. Further applications can implement their own prioritization scheme on top of QUIC: an application protocol that runs on top of QUIC can define explicit messages for signaling priority, such as those defined for HTTP/2; it can define rules that allow an endpoint to determine priority based on context; or it can provide a higher level interface and leave the determination to the application on top.</p>
<p id="rfc.section.4.2.p.2">Priority handling of retransmissions can be implemented by the sender in the transport layer. <a href="#QUIC" class="xref">[QUIC]</a> recommends to retransmit lost data before new data, unless indicated differently by the application. Currently, QUIC only provides fully reliable stream transmission, which means that prioritization of retransmissions will be beneficial in most cases, by filling in gaps and freeing up the flow control window. For partially reliable or unreliable streams, priority scheduling of retransmissions over data of higher-priority streams might not be desirable. For such streams, QUIC could either provide an explicit interface to control prioritization, or derive the prioritization decision from the reliability level of the stream.</p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#flow-control-deadlocks" id="flow-control-deadlocks">Flow Control Deadlocks</a>
</h1>
<p id="rfc.section.4.3.p.1">Flow control provides a means of managing access to the limited buffers endpoints have for incoming data.  This mechanism limits the amount of data that can be in buffers in endpoints or in transit on the network.  However, there are several ways in which limits can produce conditions that can cause a connection to either perform suboptimally or deadlock.</p>
<p id="rfc.section.4.3.p.2">Deadlocks in flow control are possible for any protocol that uses QUIC, though whether they become a problem depends on how implementations consume data and provide flow control credit.  Understanding what causes deadlocking might help implementations avoid deadlocks.</p>
<p id="rfc.section.4.3.p.3">Large messages can produce deadlocking if the recipient does not process the message incrementally.  If the message is larger than flow control credit available and the recipient does not release additional flow control credit until the entire message is received and delivered, a deadlock can occur.  This is possible even where stream flow control limits are not reached because connection flow control limits can be consumed by other streams.</p>
<p id="rfc.section.4.3.p.4">A common flow control implementation technique is for a receiver to extend credit to the sender as a the data consumer reads data. In this setting, a length-prefixed message format makes it easier for the data consumer to leave data unread in the receiver&#8217;s buffers and thereby withhold flow control credit.  If flow control limits prevent the remainder of a message from being sent, a deadlock will result.  A length prefix might also enable the detection of this sort of deadlock.  Where protocols have messages that might be processed as a single unit, reserving flow control credit for the entire message atomically ensures that this style of deadlock is less likely.</p>
<p id="rfc.section.4.3.p.5">A data consumer can read all data as it becomes available to cause the receiver to extend flow control credit to the sender and reduce the chances of a deadlock.  However, releasing flow control credit might mean that the data consumer might need other means for holding a peer accountable for the state it keeps for partially processed messages.</p>
<p id="rfc.section.4.3.p.6">Deadlocking can also occur if data on different streams is interdependent.  Suppose that data on one stream arrives before the data on a second stream on which it depends.  A deadlock can occur if the first stream is left unread, preventing the receiver from extending flow control credit for the second stream.  To reduce the likelihood of deadlock for interdependent data, the sender should ensure that dependent data is not sent until the data it depends on has been accounted for in both stream- and connection- level flow control credit.</p>
<p id="rfc.section.4.3.p.7">Some deadlocking scenarios might be resolved by cancelling affected streams with STOP_SENDING or RST_STREAM.  Cancelling some streams results in the connection being terminated in some protocols.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#packetization-and-latency" id="packetization-and-latency">Packetization and Latency</a>
</h1>
<p id="rfc.section.5.p.1">QUIC provides an interface that provides multiple streams to the application; however, the application usually cannot control how data transmitted over one stream is mapped into frames or how those frames are bundled into packets.  By default, QUIC will try to maximally pack packets with one or more stream data frames to minimize bandwidth consumption and computational costs (see section 8 of <a href="#QUIC" class="xref">[QUIC]</a>). If there is not enough data available to fill a packet, QUIC may even wait for a short time, to optimize bandwidth efficiency instead of latency. This delay can either be pre-configured or dynamically adjusted based on the observed sending pattern of the application. If the application requires low latency, with only small chunks of data to send, it may be valuable to indicate to QUIC that all data should be send out immediately. Alternatively, if the application expects to use a specific sending pattern, it can also provide a suggested delay to QUIC for how long to wait before bundle frames into a packet.</p>
<p id="rfc.section.5.p.2">Similarly, an appliaction has usually no control about the length of a QUIC packet on the wire. However, QUIC provides the ability to add a padding frame to impact the packet size. This is mainly used by QUIC itself in the first packet in order to ensure that the path is capable of transferring packets of at least a certain size. Additionally, a QUIC implementation can expose an application layer interface to specify a certain packet size. This can either be used by the application to force certian packet sizes in specific use cases/networks, or ensure that all packets are equally sized to conceal potential leakage of application layer information when the data sent by the application are not greedy. Note the initial packet must have a minimum size of 1200 bytes according to the QUIC specification. A receiver of a smaller initial packet may reject this packet in order to avoid amplification attacks.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#port-selection" id="port-selection">Port Selection</a>
</h1>
<p id="rfc.section.6.p.1">As QUIC is a general purpose transport protocol, there are no requirements that servers use a particular UDP port for QUIC in general. Instead, the same port number is used as would be used for the same application over TCP. In the case of HTTP the expectation is that port 443 is used, which has already been registered for &#8220;http protocol over TLS/SSL&#8221;. However, <a href="#QUIC-HTTP" class="xref">[QUIC-HTTP]</a> also specifies the use of Alt-Svc for HTTP/QUIC discovery which allows the server to use and announce a different port number.</p>
<p id="rfc.section.6.p.2">In general, port numbers serves two purposes: &#8220;first, they provide a demultiplexing identifier to differentiate transport sessions between the same pair of endpoints, and second, they may also identify the application protocol and associated service to which processes connect&#8221; <a href="#RFC6335" class="xref">[RFC6335]</a>. Note that the assumption that an application can be identified in the network based on the port number is less true today, due to encapsulation, mechanisms for dynamic port assignments as well as NATs.</p>
<p id="rfc.section.6.p.3">However, whenever a non-standard port is used which does not enable easy mapping to a registered service name, this can lead to blocking by network elements such as firewalls that rely on the port number as a first order of filtering.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#connection-migration" id="connection-migration">Connection Migration</a>
</h1>
<p id="rfc.section.7.p.1">QUIC supports connection migration. Even if lower-layer addresses (usually the 4-tuple of IP addresses and ports) changes, QUIC packets can still be associated with an existing connection based on the Connection ID (see also section <a href="#connid" class="xref">Section 9</a>) in the QUIC header, if present. This supports cases where address information changes due to e.g. NAT rebinding or change of the local interface.  Currently QUIC only supports failover cases. Only one &#8220;path&#8221; can be used at a time, and as soon as the new path is validated all traffic will be switched over to the next path. Of course if an endpoint decided to not use the Connection ID in short packets (Zero-length Conn ID) for a certain connection, migration is not supported for that direction of the connection.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#connection-closure" id="connection-closure">Connection closure</a>
</h1>
<p id="rfc.section.8.p.1">QUIC connections are closed either by expiration of an idle timeout or by an explicit indication of the application that a connection should be closed (immediate close). While data could still be received after the immediate close has been initiated by one endpoint (for a limited time period), the expectation is that an immediate close was negotiated at the application layer and therefore no additional data is expected from both sides.</p>
<p id="rfc.section.8.p.2">An immidate close will emit an CONNECTION_CLOSE frame. This frames has two sets of types: one for QUIC internal problems that might lead to connection closure, and one for closures initiated by the application. An application using QUIC can define application-specific error codes, e.g. see <a href="#QUIC-HTTP" class="xref">[QUIC-HTTP]</a> section 8.1. In the case of a grateful shut-down initiated by the application after application layer negotiation, a NO_ERROR code is expected. Further, the CONNECTION_CLOSE frame provides an optional reason field, that can be used to append human-readable information to an error code. Note that QUIC RESET_STREAM and STOP_SENDING frames provide similar capablities. Usually application error codes are defined to be applicabile to all three frames.</p>
<p id="rfc.section.8.p.3">Alternatively, a QUIC connection will be silently closed by each endpoint separately after an idle timeout. The idle timeout is announce for each endpoint during connection established and should be accessible by the application. If an application desires to keep the connection open for longer than the announced timeout, it can send keep-alives messages. See {#resumption-v-keepalive} for further guidance.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#connid" id="connid">Information exposure and the Connection ID</a>
</h1>
<p id="rfc.section.9.p.1">QUIC exposes some information to the network in the unencrypted part of the header, either before the encryption context is established, because the information is intended to be used by the network. QUIC has a long header that is used during connection establishment and for other control processes, and a short header that may be used for data transmission in an established connection. While the long header always exposes some information (such as the version and Connection IDs), the short header exposes at most only a single Connection ID.</p>
<p id="rfc.section.9.p.2">Note that the Connection ID in the short header may be omitted. This is a per-connection configuration option; if the Connection ID is not present, then the peer omitting the connection ID will use the same local address for the lifetime of the connection.</p>
<h1 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> <a href="#server-generated-connection-id" id="server-generated-connection-id">Server-Generated Connection ID</a>
</h1>
<p id="rfc.section.9.1.p.1">QUIC supports a server-generated Connection ID, transmitted to the client during connection establishment (see Section 6.1 of <a href="#QUIC" class="xref">[QUIC]</a>). Servers behind load balancers may need to change the Connection ID during the handshake, encoding the identity of the server or information about its load balancing pool, in order to support stateless load balancing. Once the server generates a Connection ID that encodes its identity, every CDN load balancer would be able to forward the packets to that server without retaining connection state.</p>
<p id="rfc.section.9.1.p.2">Server-generated connection IDs should seek to obscure any encoding, of routing identities or any other information. Exposing the server mapping would allow linkage of multiple IP addresses to the same host if the server also supports migration. Furthermore, this opens an attack vector on specific servers or pools.</p>
<p id="rfc.section.9.1.p.3">The best way to obscure an encoding is to appear random to observers, which is most rigorously achieved with encryption.</p>
<h1 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> <a href="#mitigating-timing-linkability-with-connection-id-migration" id="mitigating-timing-linkability-with-connection-id-migration">Mitigating Timing Linkability with Connection ID Migration</a>
</h1>
<p id="rfc.section.9.2.p.1">While sufficiently robust connection ID generation schemes will mitigate linkability issues, they do not provide full protection. Analysis of the lifetimes of six-tuples (source and destination addresses as well as the migrated CID) may expose these links anyway.</p>
<p id="rfc.section.9.2.p.2">In the limit where connection migration in a server pool is rare, it is trivial for an observer to associate two connection IDs. Conversely, in the opposite limit where every server handles multiple simultaneous migrations, even an exposed server mapping may be insufficient information.</p>
<p id="rfc.section.9.2.p.3">The most efficient mitigation for these attacks is operational, either by using a load balancing architecture that loads more flows onto a single server-side address, by coordinating the timing of migrations to attempt to increase the number of simultaneous migrations at a given time, or through other means.</p>
<h1 id="rfc.section.9.3">
<a href="#rfc.section.9.3">9.3.</a> <a href="#using-server-retry-for-redirection" id="using-server-retry-for-redirection">Using Server Retry for Redirection</a>
</h1>
<p id="rfc.section.9.3.p.1">QUIC provides a Server Retry packet that can be sent by a server in response to the Client Initial packet. The server may choose a new Connection ID in that packet and the client will retry by sending another Client Initial packet with the server-selected Connection ID. This mechanism can be used to redirect a connection to a different server, e.g. due to performance reasons or when servers in a server pool are upgraded gradually, and therefore may support different versions of QUIC. In this case, it is assumed that all servers belonging to a certain pool are served in cooperation with load balancers that forward the traffic based on the Connection ID. A server can choose the Connection ID in the Server Retry packet such that the load balancer will redirect the next Client Initial packet to a different server in that pool.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#use-of-versions-and-cryptographic-handshake" id="use-of-versions-and-cryptographic-handshake">Use of Versions and Cryptographic Handshake</a>
</h1>
<p id="rfc.section.10.p.1">Versioning in QUIC may change the protocol&#8217;s behavior completely, except for the meaning of a few header fields that have been declared to be invariant <a href="#QUIC-INVARIANTS" class="xref">[QUIC-INVARIANTS]</a>. A version of QUIC with a higher version number will not necessarily provide a better service, but might simply provide a different feature set. As such, an application needs to be able to select which versions of QUIC it wants to use.</p>
<p id="rfc.section.10.p.2">A new version could use an encryption scheme other than TLS 1.3 or higher.  <a href="#QUIC" class="xref">[QUIC]</a> specifies requirements for the cryptographic handshake as currently realized by TLS 1.3 and described in a separate specification <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>. This split is performed to enable light-weight versioning with different cryptographic handshakes.</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#enabling-new-versions" id="enabling-new-versions">Enabling New Versions</a>
</h1>
<p id="rfc.section.11.p.1">QUIC provides integrity protection for its version negotiation process.  This process assumes that the set of versions that a server supports is fixed.  This complicates the process for deploying new QUIC versions or disabling old versions when servers operate in clusters.</p>
<p id="rfc.section.11.p.2">A server that rolls out a new version of QUIC can do so in three stages.  Each stage is completed across all server instances before moving to the next stage.</p>
<p id="rfc.section.11.p.3">In the first stage of deployment, all server instances start accepting new connections with the new version.  The new version can be enabled progressively across a deployment, which allows for selective testing.  This is especially useful when the new version is compatible with an old version, because the new version is more likely to be used.</p>
<p id="rfc.section.11.p.4">While enabling the new version, servers do not advertise the new version in any Version Negotiation packets they send.  This prevents clients that receive a Version Negotiation packet from attempting to connect to server instances that might not have the new version enabled.</p>
<p id="rfc.section.11.p.5">During the initial deployment, some clients will have received Version Negotiation packets that indicate that the server does not support the new version.  Other clients might have successfully connected with the new version and so will believe that the server supports the new version.  Therefore, servers need to allow for this ambiguity when validating the negotiated version.</p>
<p id="rfc.section.11.p.6">The second stage of deployment commences once all server instances are able accept new connections with the new version.  At this point, all servers can start sending the new version in Version Negotiation packets.</p>
<p id="rfc.section.11.p.7">During the second stage, the server still allows for the possibility that some clients believe the new version to be available and some do not.  This state will persist only for as long as any Version Negotiation packets take to be transmitted and responded to.  So the third stage can follow after a relatively short delay.</p>
<p id="rfc.section.11.p.8">The third stage completes the process by enabling validation of the negotiation version as though the new version were disabled.</p>
<p id="rfc.section.11.p.9">The process for disabling an old version or rolling back the introduction of a new version uses the same process in reverse.  Servers disable validation of the old version, stop sending the old version in Version Negotiation packets, then the old version is no longer accepted.</p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<p id="rfc.section.12.p.1">This document has no actions for IANA.</p>
<h1 id="rfc.section.13">
<a href="#rfc.section.13">13.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.13.p.1">See the security considerations in <a href="#QUIC" class="xref">[QUIC]</a> and <a href="#QUIC-TLS" class="xref">[QUIC-TLS]</a>; the security considerations for the underlying transport protocol are relevant for applications using QUIC, as well.</p>
<p id="rfc.section.13.p.2">Application developers should note that any fallback they use when QUIC cannot be used due to network blocking of UDP SHOULD guarantee the same security properties as QUIC; if this is not possible, the connection SHOULD fail to allow the application to explicitly handle fallback to a less-secure alternative. See <a href="#fallback" class="xref">Section 2</a>.</p>
<h1 id="rfc.section.14">
<a href="#rfc.section.14">14.</a> <a href="#contributors" id="contributors">Contributors</a>
</h1>
<p id="rfc.section.14.p.1">Igor Lubashev contributed text to <a href="#connid" class="xref">Section 9</a> on server-selected Connection IDs.</p>
<h1 id="rfc.section.15">
<a href="#rfc.section.15">15.</a> <a href="#acknowledgments" id="acknowledgments">Acknowledgments</a>
</h1>
<p id="rfc.section.15.p.1">This work is partially supported by the European Commission under Horizon 2020 grant agreement no. 688421 Measurement and Architecture for a Middleboxed Internet (MAMI), and by the Swiss State Secretariat for Education, Research, and Innovation under contract no. 15.0268. This support does not imply endorsement.</p>
<h1 id="rfc.references">
<a href="#rfc.references">16.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">16.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="QUIC">[QUIC]</b></td>
<td class="top">
<a>Iyengar, J.</a> and <a>M. Thomson</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-transport-20">QUIC: A UDP-Based Multiplexed and Secure Transport</a>", Internet-Draft draft-ietf-quic-transport-20, April 2019.</td>
</tr>
<tr>
<td class="reference"><b id="QUIC-INVARIANTS">[QUIC-INVARIANTS]</b></td>
<td class="top">
<a>Thomson, M.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-invariants-04">Version-Independent Properties of QUIC</a>", Internet-Draft draft-ietf-quic-invariants-04, April 2019.</td>
</tr>
<tr>
<td class="reference"><b id="QUIC-TLS">[QUIC-TLS]</b></td>
<td class="top">
<a>Thomson, M.</a> and <a>S. Turner</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-tls-20">Using TLS to Secure QUIC</a>", Internet-Draft draft-ietf-quic-tls-20, April 2019.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6335">[RFC6335]</b></td>
<td class="top">
<a>Cotton, M.</a>, <a>Eggert, L.</a>, <a>Touch, J.</a>, <a>Westerlund, M.</a> and <a>S. Cheshire</a>, "<a href="https://tools.ietf.org/html/rfc6335">Internet Assigned Numbers Authority (IANA) Procedures for the Management of the Service Name and Transport Protocol Port Number Registry</a>", BCP 165, RFC 6335, DOI 10.17487/RFC6335, August 2011.</td>
</tr>
<tr>
<td class="reference"><b id="TLS13">[TLS13]</b></td>
<td class="top">
<a>Thomson, M.</a> and <a>S. Turner</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-tls-20">Using TLS to Secure QUIC</a>", Internet-Draft draft-ietf-quic-tls-20, April 2019.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">16.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="Edeline16">[Edeline16]</b></td>
<td class="top">
<a>Edeline, K.</a>, <a>Kuehlewind, M.</a>, <a>Trammell, B.</a>, <a>Aben, E.</a> and <a>B. Donnet</a>, "<a href="https://arxiv.org/abs/1612.07816">Using UDP for Internet Transport Evolution (arXiv preprint 1612.07816)</a>", December 2016.</td>
</tr>
<tr>
<td class="reference"><b id="Hatonen10">[Hatonen10]</b></td>
<td class="top">
<a>Hatonen, S.</a>, <a>Nyrhinen, A.</a>, <a>Eggert, L.</a>, <a>Strowes, S.</a>, <a>Sarolahti, P.</a> and <a>M. Kojo</a>, "<a>An experimental study of home gateway characteristics (Proc. ACM IMC 2010)</a>", October 2010.</td>
</tr>
<tr>
<td class="reference"><b id="HTTP-RETRY">[HTTP-RETRY]</b></td>
<td class="top">
<a>Nottingham, M.</a>, "<a href="https://tools.ietf.org/html/draft-nottingham-httpbis-retry-01">Retrying HTTP Requests</a>", Internet-Draft draft-nottingham-httpbis-retry-01, February 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.nottingham-httpbis-retry">[I-D.nottingham-httpbis-retry]</b></td>
<td class="top">
<a>Nottingham, M.</a>, "<a href="https://tools.ietf.org/html/draft-nottingham-httpbis-retry-01">Retrying HTTP Requests</a>", Internet-Draft draft-nottingham-httpbis-retry-01, February 2017.</td>
</tr>
<tr>
<td class="reference"><b id="PaaschNanog">[PaaschNanog]</b></td>
<td class="top">
<a>Paasch, C.</a>, "<a href="https://www.nanog.org/sites/default/files/Paasch_Network_Support.pdf">Network Support for TCP Fast Open (NANOG 67 presentation)</a>", June 2016.</td>
</tr>
<tr>
<td class="reference"><b id="QUIC-HTTP">[QUIC-HTTP]</b></td>
<td class="top">
<a>Bishop, M.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-http-20">Hypertext Transfer Protocol Version 3 (HTTP/3)</a>", Internet-Draft draft-ietf-quic-http-20, April 2019.</td>
</tr>
<tr>
<td class="reference"><b id="Swett16">[Swett16]</b></td>
<td class="top">
<a>Swett, I.</a>, "<a href="https://www.ietf.org/proceedings/96/slides/slides-96-quic-3.pdf">QUIC Deployment Experience at Google (IETF96 QUIC BoF presentation)</a>", July 2016.</td>
</tr>
<tr>
<td class="reference"><b id="Trammell16">[Trammell16]</b></td>
<td class="top">
<a>Trammell, B.</a> and <a>M. Kuehlewind</a>, "<a href="https://ripe72.ripe.net/wp-content/uploads/presentations/86-atlas-udpdiff.pdf">Internet Path Transparency Measurements using RIPE Atlas (RIPE72 MAT presentation)</a>", May 2016.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mirja Kuehlewind</span> 
	  <span class="n hidden">
		<span class="family-name">Kuehlewind</span>
	  </span>
	</span>
	<span class="org vcardline">Ericsson</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mirja.kuehlewind@ericsson.com">mirja.kuehlewind@ericsson.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Brian Trammell</span> 
	  <span class="n hidden">
		<span class="family-name">Trammell</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  <span class="vcardline">Gustav-Gull-Platz 1</span>

	  <span class="vcardline">
		<span class="locality">8004 Zurich</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ietf@trammell.ch">ietf@trammell.ch</a></span>

  </address>
</div>

</body>
</html>
